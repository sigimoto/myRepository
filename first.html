<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
     <h3 style="text-align:center ;">线程中介之Java线程池</h3>
    <p style="margin: 20px">
        在云计算、5G技术快速发展的互联网世界，为了快速响应用户的请求，宏观上除了团队内部实行DevOps机制管理、使用微服务架构进行技术设计、使用Docker或K8s进行应用部署外，微观上在程序开发中使用并行计算的能力也是必不可少的。

            而在Java开发中，最常用的便是通过线程池来最大程度利用CPU资源，实现多任务并行。
        
        
        
            我们先来看一个用户请求快速响应的案例：北京在五一假期前的突然将应急响应程度从一级降为二级，从低风险地区入京不需要隔离，这消息一经放出，仿佛沉寂的北京和人们又活过来了。
        
            大家纷纷开始在各平台购买机票、火车票，试想当你在去哪儿网查询从北京到日本的机票时，半天都刷不出来，又或是先有航班的班次、再有价格、继而有座位出来、最后出来整个图片（串行执行），蜗牛般的速度让你瞬间就离开该平台了。
        
            为了快速的响应用户请求，在程序开发中一般采用多线程并发执行，即当用户发起查询航班请求时，将获取航班班次、价格信息、座位信息、图片信息这四个任务一起执行（并行执行），再返回给用户，将原来的时间缩减3/4。
        
        在本案例中通过多线程并发执行的方式快速的响应了用户请求，接下来我们介绍线程池～ 
         在介绍线程池原理之前，首先得了解什么是线程池。线程池，望文生义，就是线程的池子，里面有很多很多的线程。

    我们知道一个程序运行时是一个进程，而程序里有很多的方法要去执行，每个方法就是一个线程，在刚刚的案例中去哪儿平台程序就是一个进程，里面获取航班班次的函数、获取航班价格的函数、获取航班位置的函数就是多个线程。

    每个函数在运行时，都需要先把线程创建起来，然后运行，最后函数执行完毕销毁线程。如果每个函数运行时都去创建线程、运行完毕都去销毁线程，这实现太耗费线程资源，如果有一个地方专门负责线程的创建和销毁，程序的函数要运行时直接去申请，那么资源的消耗是不是就降低了很多（不需要创建和销毁）、函数的响应速度是不是就提高了很多呢？（每次来就使用了，不需要去创建）、线程的管理是不是就更专业了呢？（有专门的地方管理线程），是的，这个地方就是线程池，通过池化的思想统一管理分配线程。



    接下来我们介绍在Java中线程池是如何实现的。Java中的线程池核心实现包括四个模块Executor、ExecutorService、AbstractExecutorService、ThreadPoolExecutor。

    Executor是线程池对外的接口，研发人员只需将需要运行的函数（即任务）传递给Executor即可，Executor就会完成线程的调配和任务的执行部分。

    ExecutorService是对Executor能力的扩展，研发人员是将任务一个个的传递给Executor，但是ExecutorService可将多个任务提炼成一个总任务，并且可管控线程池。

    AbstractExecutorService是对上层的抽象，将执行任务的流程串联起来，使得最底层ThreadPoolExecutor只关注于任务的实现即可。ThreadPoolExecutor则是最复杂的底层，一方面要维护自身生命周期，一方面管理线程和任务。 


    </p>
</body>
</html>